# GC调整：基础知识

调优垃圾收集与任何其他性能调优活动没有什么不同。很容易陷入随机调整200个GC相关JVM参数之一或开始更改应用程序代码的随机部分的陷阱。相反，遵循一个简单的过程将保证您实际上正朝着正确的目标前进，同时对进度保持透明：

1. 说明您的绩效目标
2. 运行测试
3. 测量结果
4. 将结果与目标进行比较
5. 如果未达到目标，请进行更改并返回运行测试

因此，作为第一步，我们需要在垃圾收集方面设定明确的性能目标。目标分为三类，这些类别对所有绩效监测和管理主题都是通用的：

- 潜伏
- 吞吐量
- 容量

在解释了一般概念之后，我们将演示如何在垃圾收集的上下文中应用这些目标。如果您已熟悉延迟，吞吐量和容量的概念，则可以决定跳过下一部分。

## 核心概念

让我们从制造中的一个例子开始，观察工厂中的装配线。该生产线是用现成的组件组装自行车。自行车以顺序方式建立在这条线上。通过监控生产线，我们测量 从框架进入生产线到装配好的自行车离开生产线到另一端需要  **四个小时**才能完成一辆自行车。

![](assets/assembly-line01-compact.jpg)



继续我们的观察，我们还可以看到每天24小时，每天一分钟组装一辆自行车。简化示例并忽略维护窗口，我们可以预测在  **任何给定时间内这样的装配线组装60辆自行车**。

通过这两项测量，我们现在拥有关于**延迟**  和  **吞吐量**的装配线当前性能的重要信息  ：

- **装配线延迟：4小时**
- **装配线吞吐量：60辆自行车/小时**

请注意，延迟是以适合手头任务的时间单位来衡量的 - 从纳秒到千年的任何事情都是一个不错的选择。系统的吞吐量在每个时间单位的完成操作中测量。操作可以是与特定系统相关的任何操作。在这个例子中，所选择的时间单位是小时，操作是组装的自行车。

配备了延迟和吞吐量的定义后，让我们在同一个工厂中进行性能调整。对自行车的需求一直保持稳定，装配线一直生产自行车，延迟时间为4小时，吞吐量为60个自行车/小时，持续数月。现在让我们想象一下销售团队成功并且对自行车的需求突然增加一倍的情况。客户需要两倍于通常的60 * 24 = 1,440辆自行车/天。工厂的表现不再令人满意，需要做些什么。

工厂经理似乎正确地断定系统的延迟并不是一个问题 - 相反，他应该关注每天生产的自行车总数。得出这个结论并假设他资金充足，假设的经理将立即采取必要措施，通过增加容量来提高吞吐量。

因此，我们现在在同一工厂中观察的不是一条而是两条相同的装配线。这两条装配线都是每天每分钟组装同一辆自行车。通过这样做，我们想象中的工厂每天生产的自行车数量增加了一倍。而不是1,440辆自行车，工厂现在每天可以运送2,880辆自行车。值得注意的是，我们还没有缩短完成单个自行车的时间甚至一毫秒 - 从头到尾完成一辆自行车仍需要四个小时。

![](assets/assembly-line02-compact.jpg)



在上面的示例中，执行了性能优化任务，同时影响了  **吞吐量和容量**。正如在任何一个好例子中我们从测量系统的当前性能开始，然后设置新目标并仅在满足目标所需的方面优化系统。

在这个例子中做出了一个重要的决定 - 重点是提高吞吐量，而不是减少延迟。在提高吞吐量的同时，我们还需要增加系统的容量。我们现在需要两条装配线来生产所需的数量，而不是单一的装配线。因此，在这种情况下，增加的吞吐量不是免费的，需要扩展解决方案以满足增加的吞吐量要求。

对于手头的性能问题，还应考虑一个重要的替代方案。系统看似无关的延迟实际上隐藏了不同的问题解决方案。如果装配线的延迟可能已经从1分钟减少到30秒，那么在没有任何额外容量的情况下突然可以实现非常相同的吞吐量增加。

在这种情况下是否可能减少延迟是不可能的或经济的并不重要。重要的是一个非常类似于软件工程的概念 - 您几乎总能在两个解决性能问题的解决方案之间进行选择。您可以为问题投入更多硬件，也可以花时间改善性能不佳的代码。

### 潜伏

GC的延迟目标必须来自通用延迟要求。通用延迟要求通常以类似于以下的形式表示：

- 所有用户事务必须在不到10秒的时间内响应
- 发票付款的90％必须在3秒内完成
- 必须在不到100毫秒的时间内将推荐产品渲染到购买屏幕

当面对与上述类似的性能目标时，我们需要确保在事务期间GC暂停的持续时间对违反要求没有太大贡献。“太多”是特定于应用程序的，需要考虑导致延迟的其他因素，包括往返外部数据源，锁争用问题以及其中的其他安全点。

让我们假设我们的性能要求表明应用程序的90％的事务需要在1,000毫秒内完成，并且任何事务都不能超过10,000毫秒。在这些通用延迟要求中，让我们再次假设GC暂停不能超过10％。由此，我们可以得出结论，90％的GC暂停必须在100毫秒内完成，并且没有GC暂停可以超过1,000毫秒。为简单起见，让我们在此示例中忽略在同一事务期间可能发生的多个暂停。

正式化要求后，下一步是测量暂停持续时间。有许多工具可供工作，在[工具](https://plumbr.io/handbook/gc-tuning-measuring)章节中有更详细的介绍，但在本节中，让我们使用GC日志，即GC暂停的持续时间。所需信息存在于不同的日志片段中，因此，让我们使用以下示例查看日期/时间数据的哪些部分实际相关：

```
2015-06-04T13：34：16.974-0200：2.578：[全GC（人体工程学）[PSYoungGen：93677K-> 70109K（254976K）] [ParOldGen：499597K-> 511230K（761856K）] 593275K-> 581339K（1016832K）， [Metaspace：2936K-> 2936K（1056768K）]，0.0713174 secs] [次：用户= 0.21 sys = 0.02，real = 0.07 secs
```

上面的示例表示在2015年6月4日13:34:16触发的单个GC暂停，仅在JVM启动后的2,578毫秒。

该事件使应用程序线程停止  **0.0713174秒**。尽管在多个内核上花费了210毫秒的CPU时间，但我们要测量的重要数字是应用程序线程的总停止时间，在这种情况下，在多核机器上使用并行GC的时间等于超过70毫秒。因此，此特定GC暂停低于所需的100 ms阈值，并满足这两个要求。

从所有GC暂停中提取类似于上述示例的信息，我们可以汇总数字并查看我们是否违反了触发的任何暂停事件的设置要求。

### 吞吐量

吞吐量要求与延迟要求不同。吞吐量要求与延迟共享的唯一相似之处在于，这些需求同样需要从通用吞吐量要求中获得。吞吐量的一般要求可以类似于以下内容：

- 该解决方案必须能够每天处理1,000,000张发票
- 该解决方案必须支持1,000个经过身份验证的用户，每个用户每隔五到十秒调用一个函数A，B或C.
- 所有客户的每周统计数据必须在每个星期日晚上12点到6点之间的不超过六小时内完成

因此，吞吐量要求不是为单个操作设置要求，而是指定系统在给定时间单位中必须处理的操作数。与延迟要求类似，GC调整部件现在需要确定在测量时间内可用于GC的总时间。特定系统可以承受多少是特定于应用程序的，但根据经验，超过10％的任何东西看起来都是可疑的。

现在让我们假设手头的需求预测系统每分钟处理1,000个事务。我们还假设在任何一分钟内GC暂停的总持续时间不能超过此时间的六秒（或10％）。

将这些要求正式化后，下一步就是收集我们需要的信息。在示例中使用的源是GC日志，我们将从中获取类似于以下内容的信息：

```
2015-06-04T13：34：16.974-0200：2.578：[全GC（人体工程学）[PSYoungGen：93677K-> 70109K（254976K）] [ParOldGen：499597K-> 511230K（761856K）] 593275K-> 581339K（1016832K）， [Metaspace：2936K-> 2936K（1056768K）]，0.0713174 secs] [次：用户= 0.21 sys = 0.02，real = 0.07 secs
```

这次我们对用户和系统时间感兴趣，而不是实时。在这种情况下，我们应该关注23毫秒（用户和系统时间为21 + 2 ms），在此期间特定的GC暂停会使CPU忙碌。更重要的是系统在多核机器上运行，转换为**0.0713174秒**的实际停止世界暂停  ，这是在下面的计算中使用的数字。

在整个测试期间从GC日志中提取与上述类似的信息，剩下要做的就是验证每分钟停止世界的总持续时间。如果在这一分钟的任何一段时间内暂停的总持续时间不超过6,000毫秒或6秒，我们就满足了我们的要求。

### 容量

容量需求对可满足吞吐量和延迟目标的环境施加了额外的限制。这些要求可能以计算资源或冷硬现金表示。例如，可以采用以下形式描述这些要求的方式：

- 系统必须部署在内存少于512 MB的Android设备上
- 系统必须部署在Amazon  **EC2上**所需的最大实例大小不得超过配置**c3.xlarge（8 G，4个核心）**
- Amazon EC2用于运行系统的月度发票不得超过12,000美元

因此，在满足延迟和吞吐量要求时必须考虑容量。凭借无限的计算能力，可以满足任何类型的延迟和吞吐量目标，但在现实世界中，预算和其他约束倾向于对可以使用的资源设置限制。

## 例

既然我们已经涵盖了性能调优的三个维度，我们就可以开始在实践中研究设置和达到GC性能目标。

为此，我们来看一个示例代码：

```java
//imports skipped for brevity
public class Producer implements Runnable {

  private static ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2);

  private Deque<byte[]> deque;
  private int objectSize;
  private int queueSize;

  public Producer(int objectSize, int ttl) {
    this.deque = new ArrayDeque<byte[]>();
    this.objectSize = objectSize;
    this.queueSize = ttl * 1000;
  }

  @Override
  public void run() {
    for (int i = 0; i < 100; i++) { deque.add(new byte[objectSize]); if (deque.size() > queueSize) {
        deque.poll();
      }
    }
  }

  public static void main(String[] args) throws InterruptedException {
    executorService.scheduleAtFixedRate(new Producer(200 * 1024 * 1024 / 1000, 5), 0, 100, TimeUnit.MILLISECONDS);
    executorService.scheduleAtFixedRate(new Producer(50 * 1024 * 1024 / 1000, 120), 0, 100, TimeUnit.MILLISECONDS);
    TimeUnit.MINUTES.sleep(10);
    executorService.shutdownNow();
  }
}
```

代码提交两个作业，每100毫秒运行一次。每个作业都模拟具有特定生命周期的对象：它创建对象，让它们离开预定的时间，然后忘记它们，允许GC回收内存。

运行带有以下参数的GC日志记录的示例时：

```
-XX：+ PrintGCDetails -XX：+ PrintGCDateStamps -XX：+ PrintGCTimeStamps
```

我们立即看到GC在日志文件中的影响，类似于以下内容：

```
2015-06-04T13：34：16.119-0200：1.723：[GC（分配失败）[PSYoungGen：114016K-> 73191K（234496K）] 421540K-> 421269K（745984K），0.0858176 secs] [次：用户= 0.04 sys = 0.06，真实= 0.09秒] 
2015-06-04T13：34：16.738-0200：2.342：[GC（分配失败）[PSYoungGen：234462K-> 93677K（254976K）] 582540K-> 593275K（766464K），0.2357086 secs] [次：用户= 0.11 sys = 0.14，实际= 0.24秒] 
2015-06-04T13：34：16.974-0200：2.578：[全GC（人体工程学）[PSYoungGen：93677K-> 70109K（254976K）] [ParOldGen：499597K-> 511230K（761856K）] 593275K-> 581339K（1016832K）， [Metaspace：2936K-> 2936K（1056768K）]，0.0713174 secs] [次：用户= 0.21 sys = 0.02，real = 0.07 secs]
```

根据日志中的信息，我们可以从三个不同的目标开始改善这种情况：

1. 确保最坏情况的GC暂停不超过预定阈值
2. 确保应用程序线程停止的总时间不超过预定阈值
3. 降低基础架构成本，同时确保我们仍能实现合理的延迟和/或吞吐量目标

为此，上面的代码在三种不同的配置上运行了10分钟，提供了下表中总结的三种截然不同的结果：

| **堆**  | **GC算法**                | **有用的工作** | **停顿时间最长** |
| ------- | ------------------------- | -------------- | ---------------- |
| -Xmx12g | -XX：+ UseConcMarkSweepGC | 89.8％         | 560毫秒          |
| -Xmx12g | -XX：+ UseParallelGC      | 91.5％         | 1,104毫秒        |
| -Xmx8g  | -XX：+ UseConcMarkSweepGC | 66.3％         | 1,610毫秒        |

该实验使用不同的GC算法和不同的堆大小运行相同的代码，以测量关于延迟和吞吐量的垃圾收集暂停的持续时间。在以下章节中给出了实验的细节和结果的解释。

请注意，为了使示例尽可能简单，只更改了有限数量的输入参数，例如，实验不会测试不同数量的内核或使用不同的堆布局。

### 调整延迟

让我们假设我们有一个要求，即**所有作业必须在1000毫秒内处理**。我们知道实际的作业处理只需要100毫秒，我们可以简化并减少单个GC暂停的延迟要求。我们的要求现在指出，**GC暂停可以使应用程序线程停止超过900毫秒。** 回答这个问题很简单，只需要解析GC日志文件并找到单个GC暂停的最大暂停时间。

再看一下测试中使用的三个配置选项：

| **堆**  | **GC算法**                | **有用的工作** | **停顿时间最长** |
| ------- | ------------------------- | -------------- | ---------------- |
| -Xmx12g | -XX：+ UseConcMarkSweepGC | 89.8％         | **560毫秒**      |
| -Xmx12g | -XX：+ UseParallelGC      | 91.5％         | 1,104毫秒        |
| -Xmx8g  | -XX：+ UseConcMarkSweepGC | 66.3％         | 1,610毫秒        |

我们可以看到有一个配置已经符合这个要求。运行代码：

```
java -Xmx12g -XX：+ UseConcMarkSweepGC Producer
```

导致最大GC暂停时间为  **560毫秒，**  这很好地通过了 为满足延迟要求而设置的  **900毫秒**阈值。如果没有违反吞吐量和容量要求，我们可以得出结论，我们已经完成了GC调整任务，并且可以完成调整练习。

### 调整吞吐量

让我们假设我们的吞吐量目标是**每小时**处理  **13,000,000个工作**。再次使用的示例配置为我们提供了满足需求的配置：

| **堆**  | **GC算法**                | **有用的工作** | **停顿时间最长** |
| ------- | ------------------------- | -------------- | ---------------- |
| -Xmx12g | -XX：+ UseConcMarkSweepGC | 89.8％         | 560毫秒          |
| -Xmx12g | -XX：+ UseParallelGC      | **91.5％**     | 1,104毫秒        |
| -Xmx8g  | -XX：+ UseConcMarkSweepGC | 66.3％         | 1,610毫秒        |

将此配置运行为：

```
java -Xmx12g -XX：+ UseParallelGC Producer
```

我们可以看到，CPU在8.5％的时间内被GC阻止，剩余  **91.5％**  的计算能力用于有用的工作。为简单起见，我们将忽略示例中的其他安全点。现在我们必须考虑到：

1. 单个核心在100毫秒内处理一个作业
2. 因此，在一分钟内，一个核心可以处理60,000个工作岗位
3. 在一小时内，单个核心可以处理3.6 M个工作
4. 我们有四个核心，因此可以在一小时内处理4 x 3.6 M = 14.4 M的作业

凭借这一理论处理能力，我们可以进行简单的计算，并得出结论：在一小时内，我们实际上可以处理   14.4 M理论最大值的**91.5％**，从而  **达到13,176,000个**  处理作业/小时，满足我们的要求。

值得注意的是，如果我们同时需要满足上一节中设置的延迟要求，我们就会遇到麻烦，因为这种情况下的最坏情况延迟接近前一次配置的两倍。这次记录中最长的GC暂停阻塞了应用程序线程1,104 ms。

### 调整容量

我们假设我们必须将我们的解决方案部署到商用级硬件上，最多可提供四个内核和10 G RAM。从这里我们可以得出我们的容量要求，即**应用程序**的**最大堆空间不能超过8 GB**。有了这个要求，我们需要转向运行测试的第三个配置：

| **堆**     | **GC算法**                | **有用的工作** | **停顿时间最长** |
| ---------- | ------------------------- | -------------- | ---------------- |
| -Xmx12g    | -XX：+ UseConcMarkSweepGC | 89.8％         | 560毫秒          |
| -Xmx12g    | -XX：+ UseParallelGC      | 91.5％         | 1,104毫秒        |
| **-Xmx8g** | -XX：+ UseConcMarkSweepGC | 66.3％         | 1,610毫秒        |

该应用程序可以在此配置上运行

```
java -Xmx8g -XX：+ UseConcMarkSweepGC Producer
```

但延迟和特别是吞吐量数字都急剧下降：

- GC现在阻止CPU进行更多有用的工作，因为这种配置只留下  **66.3％**  的CPU用于有用的工作。因此，此配置会将吞吐量从最佳情况下的  **13,176,000个小时/小时**  降至**每小时****9,547,200个小时**
-  在最坏的情况下，我们现在面临  **1,610毫秒**的额外延迟，而不是**560毫秒** 

从三个方面来看，显然您不能仅仅针对“性能”进行优化，而是需要考虑三个不同的维度，测量和调整延迟和吞吐量，并考虑容量限制。